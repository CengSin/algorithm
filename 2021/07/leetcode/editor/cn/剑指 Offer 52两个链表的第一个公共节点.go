//è¾“å…¥ä¸¤ä¸ªé“¾è¡¨ï¼Œæ‰¾å‡ºå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚
//
// å¦‚ä¸‹é¢çš„ä¸¤ä¸ªé“¾è¡¨ï¼š
//
//
//
// åœ¨èŠ‚ç‚¹ c1 å¼€å§‹ç›¸äº¤ã€‚
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//
// è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, s
//kipB = 3
//è¾“å‡ºï¼šReference of the node with value = 8
//è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªåˆ—è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,0,1
//,8,4,5]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
//
//
//
//
// ç¤ºä¾‹ 2ï¼š
//
//
//
// è¾“å…¥ï¼šintersectValÂ = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB =
// 1
//è¾“å‡ºï¼šReference of the node with value = 2
//è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 2 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªåˆ—è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [0,9,1,2,4]ï¼Œé“¾è¡¨ B ä¸º [3,2,4
//]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 1 ä¸ªèŠ‚ç‚¹ã€‚
//
//
//
//
// ç¤ºä¾‹ 3ï¼š
//
//
//
// è¾“å…¥ï¼šintersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
//è¾“å‡ºï¼šnull
//è¾“å…¥è§£é‡Šï¼šä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [2,6,4]ï¼Œé“¾è¡¨ B ä¸º [1,5]ã€‚ç”±äºè¿™ä¸¤ä¸ªé“¾è¡¨ä¸ç›¸äº¤ï¼Œæ‰€ä»¥ intersectVal å¿…é¡»ä¸º 0ï¼Œè€Œ
// skipA å’Œ skipB å¯ä»¥æ˜¯ä»»æ„å€¼ã€‚
//è§£é‡Šï¼šè¿™ä¸¤ä¸ªé“¾è¡¨ä¸ç›¸äº¤ï¼Œå› æ­¤è¿”å› nullã€‚
//
//
//
//
// æ³¨æ„ï¼š
//
//
// å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null.
// åœ¨è¿”å›ç»“æœåï¼Œä¸¤ä¸ªé“¾è¡¨ä»é¡»ä¿æŒåŸæœ‰çš„ç»“æ„ã€‚
// å¯å‡å®šæ•´ä¸ªé“¾è¡¨ç»“æ„ä¸­æ²¡æœ‰å¾ªç¯ã€‚
// ç¨‹åºå°½é‡æ»¡è¶³ O(n) æ—¶é—´å¤æ‚åº¦ï¼Œä¸”ä»…ç”¨ O(1) å†…å­˜ã€‚
// æœ¬é¢˜ä¸ä¸»ç«™ 160 é¢˜ç›¸åŒï¼šhttps://leetcode-cn.com/problems/intersection-of-two-linked-lis
//ts/
//
// Related Topics å“ˆå¸Œè¡¨ é“¾è¡¨ åŒæŒ‡é’ˆ
// ğŸ‘ 304 ğŸ‘ 0

package main

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
//getIntersectionNode è·å–ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚
// ç¬¬ä¸€ç§æ€è·¯ï¼šåœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œä¿®æ”¹é“¾è¡¨çš„å€¼ä¸ºæŸä¸€ä¸ªå›ºå®šçš„å€¼ï¼Œå¦‚æœç¬¬äºŒæ¬¡ç¢°åˆ°è¿™ä¸ªå€¼ï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯é“¾è¡¨çš„é‡åˆç‚¹
// ç¬¬äºŒç§æ€è·¯ï¼šä¸¤ä¸ªé“¾è¡¨å¦‚æœæœ‰ä¸€ä¸ªå…¬å…±çš„èŠ‚ç‚¹çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå…¬å…±çš„èŠ‚ç‚¹ä¹‹åçš„èŠ‚ç‚¹åº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»å°¾éƒ¨èŠ‚ç‚¹å¼€å§‹éå†ã€‚
//   å½“åŒ¹é…åˆ°ç¬¬ä¸€ä¸ªä¸ä¸€æ ·çš„èŠ‚ç‚¹çš„æ—¶å€™ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚æˆ‘ä»¬éå†é“¾è¡¨æ˜¯ä»å‰å¾€åéå†çš„ï¼Œä½†æ˜¯è¦æ±‚ä»åå¾€å‰æ¯”è¾ƒï¼Œæœ€æ–°éå†çš„èŠ‚ç‚¹æœ€åæ¯”è¾ƒï¼Œç¬¦åˆæ ˆçš„ç‰¹ç‚¹ã€‚
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}

	if headA == headB {
		return headA
	}

	var stack1, stack2 []*ListNode
	travese := func(head *ListNode, stack *[]*ListNode) {
		if head == nil {
			return
		}

		for head != nil {
			tmp := head
			*stack = append(*stack, tmp)
			head = head.Next
		}
	}

	travese(headA, &stack1)
	travese(headB, &stack2)

	i := 0
	for i < len(stack1) && i < len(stack2) && stack1[len(stack1)-i-1] == stack2[len(stack2)-i-1] {
		i++
	}

	// å¦‚æœiè¶…è¿‡äº†æŸä¸ªé“¾è¡¨çš„é•¿åº¦çš„é—®é¢˜
	if i < len(stack1) && stack1[len(stack1)-i-1].Next != nil {
		return stack1[len(stack1)-i-1].Next
	}
	return stack2[len(stack2)-i-1].Next
}

//leetcode submit region end(Prohibit modification and deletion)
